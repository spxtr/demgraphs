<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>demgraphs</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@3.5.1/dist/chart.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/date-fns@2.25.0/index.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.2.1/dist/chartjs-plugin-zoom.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/google-palette@1.1.0/palette.min.js"></script>
<script>
const data = {

		
	  datasets: [
	  {% for dataset in datasetDict %}
		  {
			label: "{{dataset}}",
			data: [
			{% for time, value in datasetDict[dataset] %}
			{x: {{time}}, y:{{value}}},
			{% endfor %}
			]
		  },
	  {% endfor %}
	  ]
};


function _rebuildChart() {
	if (document.getElementById("Line").checked) {
		var plotType = 'line';
	} else {
			var plotType = 'scatter';
	}
	var temp = jQuery.extend(true, {}, config); // Chart type doesn't update dynamically, so must copy configuration and create new chart
	temp.type = plotType; 
	chart.destroy()
	chart = new Chart(document.getElementById('chart'), temp);
	chart.resetZoom(mode='none');
	chart.update('none');
}

function _setDataColors() {
	var _dataLength = data.datasets.length
	var color_seq = palette('tol', _dataLength).map(function(hex) {
		return '#' + hex;
	});
	//data.datasets[0].data.length = 0;
	for (var i = 0; i < _dataLength; i++) {
		data.datasets[i].backgroundColor = color_seq[i];
		data.datasets[i].borderColor = color_seq[i];
	}
	_rebuildChart()
}

function show() {
	let query = new URLSearchParams();
	//selector = document.getElementsByName("selector")[0].value;
	const selected = document.querySelectorAll('#selector option:checked');
	var selector = Array.from(selected).map(el => el.value);

	if (selector.length > 0) {
		query.append('selector', selector);
	} else {
		return
	}

	max_points = document.getElementsByName("max_points")[0].value;
	if (max_points > 0) {
		query.append('max_points', max_points);
	}
	start_date = document.getElementsByName("start_date")[0].value;
	end_date = document.getElementsByName("end_date")[0].value;
	<!-- Currently no checking that start date is less than end date. Have to consider case where one of start date or end_date isn't selected -->
	query.append('start_date', start_date);
	query.append('end_date', end_date);
	start_time = document.getElementsByName("start_time")[0].value;
	end_time = document.getElementsByName("end_time")[0].value;
	query.append('start_time', start_time);
	query.append('end_time', end_time);
	let request = new Request('data?' + query.toString());
	let start = performance.now()
	fetch(request).then(response => {
		if (response.status === 200) {
			return response.json();
		} else {
			throw new Error("non 200 response: " + response.status);
		}
	}).then(response => {
		let end = performance.now()
		var data_length = 0
		//data.datasets[0].data.length = 0;
		dataKeys = Object.keys(response)
		data.datasets = [{}];
		for (var i = 0; i < selector.length; i++) {
			data.datasets[i] = {};
			data.datasets[i].data = [];
			data.datasets[i].label = selector[i];
			if (dataKeys.includes(selector[i])) {
				data_length += response[selector[i]].length;
				for (var j = 0; j < response[selector[i]].length; j++) {
					data.datasets[i].data.push({x: response[selector[i]][j][0], y: response[selector[i]][j][1]});
				}
			}
		}
		document.getElementById("response").innerText = "Loaded " + data_length + " results in " + (end - start)+ " ms";
		document.getElementById('permalink').value = location.protocol+'//'+location.host+location.pathname + '?display=true&' + query.toString();
		_setDataColors()
	}).catch(error => {
		console.error(error);
	});
}
</script>
<body>
<form>
<label>Permanent Link <input type="url" id="permalink" name="permalink" value={{url_value}} size="80" readonly></label> <br>
<label>Start date <input id="start_date" name="start_date" type="date" value={{start_date}}></label> <label>time <input id="start_time" name="start_time" type="time" value={{start_time}}></label><br>
<label>End date <input id="end_date" name="end_date" type="date" value={{end_date}}></label> <label>time <input id="end_time" name="end_time" type="time" value={{end_time}}></label><br>
<label>Max points <input id="max_points" name="max_points" type="number" value="1000" disabled></label> <label>Skip every <input name="skip_every" type="number" value="1" disabled></label><br>
<label>Line plot? <input type="checkbox" id="Line" name="Line" {% if line_plot_check %} checked=true {% endif %}></label><br>
<input type="button" value="Show" onClick="show();">
<hr>
<span id="response"></span>
<div class="container" style="display: flex; height: 100px;">
        <div style="width: 15%;">
            <label>Dataset <select id="selector" name="selector" multiple>
			{% for groupName in groupNamesDict %}
				<optgroup label = {{groupName}}>
				{% for dataName, currSelected in groupNamesDict[groupName] %}
					{% if groupName == 'Other' %}
						<option value = {{dataName}} {% if currSelected %} selected=true {% endif %}>{{dataName}}</option>
					{% else %}
						<option value = {{groupName + '.' + dataName}} {% if currSelected %} selected=true {% endif %}>{{dataName}}</option>
					{% endif %}
				{% endfor %}
			{% endfor %}
			</select></label>
        </div>
        <div style="flex-grow: 1;">
           <canvas id="chart"></canvas>
        </div>
</div>
<script>
const config = {
	type: 'scatter',
	data: data,
	options: {
		scales: {
			x: {
				type: "time",
				time: {
                    displayFormats: {
                        hour: 'h:mm a M/d/yyyy'
						}
					}
				}
		},
		animation: {
			duration: 0
		},
		plugins: {
		  zoom: {
			zoom: {
			  wheel: {
				enabled: true,
				speed: 0.05,
			  },
			  pinch: {
				enabled: true
			  },
			  mode: 'xy',
			},
			pan: {
				enabled: true,
				mode: 'xy',
			}
		  }
	  }
	}
};

var chart = new Chart(
  document.getElementById('chart'),
  config
);
</script>

<script>
function getSelectors() {
	var select = document.getElementById("selector"); 
	let request = new Request('selectors?');
	fetch(request).then(response => {
			if (response.status === 200) {
				return response.json();
			} else {
				throw new Error("non 200 response: " + response.status);
			}
		}).then(response => {
			var name_groups = {};
			for (var i = 0; i < response.length; i++) {
				var data_name = response[i][0];
				var name_group= data_name.substring(0, data_name.indexOf('.'));
				var name_element = data_name.substring(data_name.indexOf('.')+1);
				if (name_group=='') {
					name_group = 'Other';
				}
				if (!(name_group in name_groups)) {
					var el_group = document.createElement("OPTGROUP");
					el_group.label = name_group;
					name_groups[name_group] = el_group;
				}

			  
				var el = document.createElement("option");
				el.text = name_element;
				el.value = data_name;
				name_groups[name_group].appendChild(el)
			 
			}
			
			for (let key in name_groups) {
				select.add(name_groups[key]);
			}
			const url = new URL(window.location.href);
			if (url.searchParams.get('display')) {
				for(pair of url.searchParams.entries()) {
					element = document.getElementById(pair[0]);
					if (typeof(element) != 'undefined' && element != null) {
						if (pair[0] === 'selector') {
							datasetSelectors = pair[1].split(',');
							for ( var i = 0, l = element.options.length, o; i < l; i++ ) {
							  o = element.options[i];
							  if ( datasetSelectors.indexOf( o.value ) != -1 )
							  {
								o.selected = true;
							  }
							}
						} else {
							document.getElementById(pair[0]).value = pair[1];
						}
					}
				}
				show();
			}
		}).catch(error => {
			console.error(error);
		});
}
</script>
<script>
{% if showData %}
	_setDataColors()
{% endif %}
document.getElementById('permalink').value = window.location.href; 
</script>

</form>
